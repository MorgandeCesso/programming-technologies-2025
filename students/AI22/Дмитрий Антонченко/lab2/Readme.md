# Telegram Chat Bot Assistant

## Описание

Это реализация лабораторной работы №2 по разработке Telegram бота. Бот использует AI модель llama-3.1-8b-instant от Groq для генерации ответов и SQLite для хранения истории сообщений. Проект демонстрирует работу с асинхронной обработкой сообщений, управлением состоянием пользователей и взаимодействием с внешними API.

Основные возможности:
- Базовая команда /start с приветствием
- Система контекста диалога (последние 12 сообщений)
- Хранение сообщений в базе данных (SQLite)
- Поддержка имени пользователя в диалоге
- Системный промпт для настройки поведения ассистента
- Команда /reset-context для сброса контекста
- Поддержка отправки изображений

## Используемые технологии

| Технология | Версия | Назначение |
|-----------|--------|-----------|
| **Python** | 3.10+ | Язык программирования |
| **Aiogram** | 3.x | Асинхронная библиотека для работы с Telegram API |
| **Groq API** | 1.0+ | LLM (модель `llama-3.1-8b-instant`) |
| **SQLAlchemy** | 2.0+ | ORM для работы с БД |
| **aiosqlite** | 0.22+ | Асинхронный драйвер для SQLite |
| **SQLite** | встроенный | СУБД (файл `bot.db`) |
| **python-dotenv** | 1.2+ | Управление переменными окружения |

## Процесс разработки

### Этап 1. Планирование и выбор стека

Изначально была задача создать простейший чат-бот в Telegram, который умеет:
- Принимать сообщения от пользователя
- Запрашивать ответы у нейросети
- Помнить контекст диалога
- Работать с пользовательскими данными

Был выбран максимально простой и понятный стек:
- Aiogram v3 (асинхронная библиотека для Telegram API) — легче, чем Django для такой задачи
- SQLAlchemy с асинхронным ORM (вместо простого sqlite3) — удобнее работать с данными
- SQLite — не требует отдельного сервера БД
- Groq API вместо OpenAI — бесплатнее, быстрее и проще для обучения

### Этап 2. Настройка окружения

Первый этап всегда начинается с создания виртуального окружения и установки зависимостей. Это необходимо, чтобы не засорять глобальное Python окружение и иметь полный контроль над версиями библиотек проекта.

Команды:
```bash
python -m venv venv
venv\Scripts\activate
pip install aiogram groq python-dotenv SQLAlchemy aiosqlite
pip freeze > requirements.txt
```

Затем создали файл .env для хранения секретных ключей:
```env
BOT_TOKEN=токен_от_BotFather
GROQ_API_KEY=ключ_от_Groq
SYSTEM_PROMPT=Ты дружелюбный ассистент. Отвечай кратко и по делу.
CONTEXT_LIMIT=12
DB_URL=sqlite+aiosqlite:///bot.db
```

### Этап 3. Архитектура и структура проекта

Проект организован по функциональным модулям:
<img width="888" height="818" alt="2" src="https://github.com/user-attachments/assets/113ceb79-2330-41e1-acf1-d6042cf51121" />

**Папка db/** — все что связано с базой данных:
- base.py — базовый класс для всех моделей SQLAlchemy
- models.py — описание таблиц (User и Message)
- session.py — конфигурация асинхронного движка БД
- crud.py — функции для работы с данными (Create, Read, Update, Delete)

**Папка utils/** — вспомогательные функции:
- loader.py — инициализация бота и диспетчера Aiogram
- gpt.py — функция для получения ответа от Groq API

**Папка handlers/** — обработчики событий от Telegram:
- commands.py — обработчики команд (/start, /reset-context)
- messages.py — обработчик текстовых сообщений и фотографий

**Файлы в корне:**
- config.py — загрузка переменных окружения
- main.py — точка входа приложения

### Этап 4. Разработка базы данных

Логично начать с БД, так как всё остальное будет с ней взаимодействовать.

В моделях определены две основные сущности:

**User** — каждый пользователь:
- id — уникальный ID в БД
- tg_id — Telegram ID (уникальный, нужен для быстрого поиска)
- full_name — имя пользователя
- messages — список связанных сообщений (отношение 1-ко-многим)

**Message** — каждое сообщение в диалоге:
- id — уникальный ID
- user_id — на какого пользователя сослаться
- role — кто говорит ("user", "assistant" или "system")
- content — текст сообщения
- created_at — время отправки (автоматически устанавливается)
<img width="2560" height="1396" alt="1" src="https://github.com/user-attachments/assets/01e0ee49-7db3-487b-8eeb-54c2d1971560" />

Связь между ними: один пользователь имеет много сообщений, одно сообщение принадлежит одному пользователю.

В файле crud.py написаны функции для работы с БД:
- get_or_create_user() — ищет пользователя по Telegram ID, если не найден — создаёт
- add_message() — добавляет сообщение в таблицу
- get_last_messages() — извлекает последние N сообщений для контекста
- reset_context() — удаляет все сообщения пользователя

### Этап 5. Интеграция с Groq API

Вместо использования OpenAI API (платно), выбрали Groq. API совместим — принимает такой же формат сообщений.
```bash
import logging
from groq import AsyncGroq
from config import GROQ_API_KEY, SYSTEM_PROMPT

client = AsyncGroq(api_key=GROQ_API_KEY)

async def get_response(user_name: str, context_messages: list[dict]) -> str:
    """
    context_messages: [{"role": "user" | "assistant", "content": "..."}]
    """
    try:
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT},
            {
                "role": "system",
                "content": f"Имя пользователя: {user_name}. Всегда обращайся к нему по имени."
            },
            *context_messages
        ]

        response = await client.chat.completions.create(
            model="llama-3.1-8b-instant",
            messages=messages,
            temperature=0.7
        )

        return response.choices[0].message.content

    except Exception as e:
        logging.error(f"Groq error: {e}")
        return "Произошла ошибка при получении ответа от модели."

```






Функция get_response() делает следующее:
1. Собирает систему из двух частей:
   - SYSTEM_PROMPT из .env (общее поведение бота)
   - Дополнительное указание обращаться по имени пользователя
2. Добавляет исторический контекст (последние сообщения из БД)
3. Отправляет всё в Groq API (модель llama-3.1-8b-instant)
4. Возвращает ответ ассистента


### Этап 6. Обработчики команд

В Aiogram обработчики регистрируются через декоратор @dp.message(...).

**Команда /start:**
- Получает Telegram ID и имя пользователя из объекта Message
- Создаёт или получает существующего пользователя в БД
- Отправляет приветственное сообщение с информацией о доступных командах

**Команда /reset-context:**
- Создаёт или получает пользователя
- Удаляет все его сообщения из БД через функцию reset_context()
- Подтверждает сброс контекста
<img width="2110" height="166" alt="4" src="https://github.com/user-attachments/assets/66512447-d61f-4ad9-aa17-2931897c591b" />

### Этап 7. Обработчик сообщений

Основная логика работает в message_handler():

1. Проверяет что пришло текстовое сообщение (не команда, не медиа)
2. Создаёт или получает пользователя в БД
3. Сохраняет сообщение пользователя в БД с role="user"
4. Загружает последние 12 сообщений из БД (контекст)
5. Отправляет контекст в Groq API вместе с именем пользователя
6. Получает ответ ассистента
7. Сохраняет ответ в БД с role="assistant"
8. Отправляет ответ пользователю в Telegram

Благодаря асинхронности вся цепочка работает быстро, даже если много пользователей.

**Обработчик фотографий:**
- Отдельный обработчик проверяет наличие photo в сообщении
- Сохраняет в БД что пользователь отправил фото (как "[PHOTO]")
- Отвечает текстом "Вы отправили картинку!"
- Не обрабатывает фото нейросетью (как и требовало задание)

### Этап 8. Главный файл (main.py)
```bash
import asyncio
import logging
import sys

from handlers import dp
from utils.loader import bot

from db.session import engine
from db.base import Base

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def main():
    await init_db()
    await dp.start_polling(bot)

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, stream=sys.stdout)
    asyncio.run(main())
```

Точка входа делает три вещи:
1. init_db() — создаёт все таблицы в БД при первом запуске
2. dp.start_polling(bot) — запускает бесконечный цикл, который слушает входящие сообщения от Telegram
3. Логирование настраивается на уровне INFO в консоль

## Установка и настройка

```bash
python main.py
```

После успешного запуска бот начнет слушать входящие сообщения.

## Команды бота

| Команда | Описание |
|---------|----------|
| /start | Начало диалога, приветствие и информация о командах |
| /reset-context | Сброс контекста диалога (удаление истории сообщений) |

## Как это работает

Основной рабочий процесс бота:

1. Пользователь отправляет /start
2. Бот создает запись пользователя в БД
3. Пользователь отправляет сообщение
4. Сообщение сохраняется в БД с ролью "user"
5. Бот загружает последние сообщения из контекста (до 12)
6. Отправляет их вместе с системным промптом в Groq API
7. Получает ответ ассистента и сохраняет его в БД
8. Отправляет ответ пользователю в Telegram
## Вывод

В ходе выполнения лабораторной работы №2 был разработан Telegram чат-бот с поддержкой искусственного интеллекта, асинхронной обработкой сообщений и хранением данных в базе данных. В рамках работы были получены практические навыки разработки Telegram-ботов с использованием библиотеки Aiogram, а также интеграции с внешним API нейросетевой модели (Groq API, llama-3.1-8b-instant).

В процессе разработки была реализована полноценная архитектура приложения с разделением на модули, что упростило поддержку и расширение функциональности. Для хранения пользовательских данных и истории сообщений использовалась база данных SQLite, а работа с ней осуществлялась через ORM SQLAlchemy в асинхронном режиме, что позволило избежать написания SQL-запросов вручную и обеспечило корректную работу в асинхронной среде.

Бот поддерживает:

хранение истории диалога и использование её как контекста для генерации ответов;

персонализацию общения за счёт использования имени пользователя;

системный промпт для управления поведением ассистента;

команду сброса контекста;

обработку изображений в соответствии с требованиями задания.

Таким образом, цель лабораторной работы была полностью достигнута: создан простой, но функциональный Telegram-бот, демонстрирующий принципы асинхронного программирования, работу с ORM, управление состоянием пользователей и взаимодействие с современными LLM-моделями через API. Полученные знания могут быть использованы при разработке более сложных ботов и сервисов на Python.
## Скрины работы бота
<img width="2104" height="1352" alt="7" src="https://github.com/user-attachments/assets/bc9166cf-60e2-4a22-9aa5-e3551e8126ff" />
<img width="2104" height="1364" alt="6" src="https://github.com/user-attachments/assets/1eaaf9aa-b027-4014-a761-6f15e7149bf3" />
