# Telegram Chat Bot Assistant

## Описание

Это реализация лабораторной работы №2 по разработке Telegram бота. Бот использует AI модель llama-3.1-8b-instant от Groq для генерации ответов и SQLite для хранения истории сообщений. Проект демонстрирует работу с асинхронной обработкой сообщений, управлением состоянием пользователей и взаимодействием с внешними API.

Основные возможности:
- Базовая команда /start с приветствием
- Система контекста диалога (последние 12 сообщений)
- Хранение сообщений в базе данных (SQLite)
- Поддержка имени пользователя в диалоге
- Системный промпт для настройки поведения ассистента
- Команда /reset-context для сброса контекста
- Поддержка отправки изображений

## Используемые технологии

| Технология | Версия | Назначение |
|-----------|--------|-----------|
| **Python** | 3.10+ | Язык программирования |
| **Aiogram** | 3.x | Асинхронная библиотека для работы с Telegram API |
| **Groq API** | 1.0+ | LLM (модель `llama-3.1-8b-instant`) |
| **SQLAlchemy** | 2.0+ | ORM для работы с БД |
| **aiosqlite** | 0.22+ | Асинхронный драйвер для SQLite |
| **SQLite** | встроенный | СУБД (файл `bot.db`) |
| **python-dotenv** | 1.2+ | Управление переменными окружения |

## Процесс разработки

### Этап 1. Планирование и выбор стека

Изначально была задача создать простейший чат-бот в Telegram, который умеет:
- Принимать сообщения от пользователя
- Запрашивать ответы у нейросети
- Помнить контекст диалога
- Работать с пользовательскими данными

Был выбран максимально простой и понятный стек:
- Aiogram v3 (асинхронная библиотека для Telegram API) — легче, чем Django для такой задачи
- SQLAlchemy с асинхронным ORM (вместо простого sqlite3) — удобнее работать с данными
- SQLite — не требует отдельного сервера БД
- Groq API вместо OpenAI — бесплатнее, быстрее и проще для обучения

### Этап 2. Настройка окружения

Первый этап всегда начинается с создания виртуального окружения и установки зависимостей. Это необходимо, чтобы не засорять глобальное Python окружение и иметь полный контроль над версиями библиотек проекта.

Команды:
```bash
python -m venv venv
venv\Scripts\activate
pip install aiogram groq python-dotenv SQLAlchemy aiosqlite
pip freeze > requirements.txt
```

Затем создали файл .env для хранения секретных ключей:
```env
BOT_TOKEN=токен_от_BotFather
GROQ_API_KEY=ключ_от_Groq
SYSTEM_PROMPT=Ты дружелюбный ассистент. Отвечай кратко и по делу.
CONTEXT_LIMIT=12
DB_URL=sqlite+aiosqlite:///bot.db
```

### Этап 3. Архитектура и структура проекта

Проект организован по функциональным модулям:
<img width="888" height="818" alt="2" src="https://github.com/user-attachments/assets/113ceb79-2330-41e1-acf1-d6042cf51121" />

**Папка db/** — все что связано с базой данных:
- base.py — базовый класс для всех моделей SQLAlchemy
- models.py — описание таблиц (User и Message)
- session.py — конфигурация асинхронного движка БД
- crud.py — функции для работы с данными (Create, Read, Update, Delete)

**Папка utils/** — вспомогательные функции:
- loader.py — инициализация бота и диспетчера Aiogram
- gpt.py — функция для получения ответа от Groq API

**Папка handlers/** — обработчики событий от Telegram:
- commands.py — обработчики команд (/start, /reset-context)
- messages.py — обработчик текстовых сообщений и фотографий

**Файлы в корне:**
- config.py — загрузка переменных окружения
- main.py — точка входа приложения

### Этап 4. Разработка базы данных

Логично начать с БД, так как всё остальное будет с ней взаимодействовать.

В моделях определены две основные сущности:

**User** — каждый пользователь:
- id — уникальный ID в БД
- tg_id — Telegram ID (уникальный, нужен для быстрого поиска)
- full_name — имя пользователя
- messages — список связанных сообщений (отношение 1-ко-многим)

**Message** — каждое сообщение в диалоге:
- id — уникальный ID
- user_id — на какого пользователя сослаться
- role — кто говорит ("user", "assistant" или "system")
- content — текст сообщения
- created_at — время отправки (автоматически устанавливается)
<img width="2560" height="1396" alt="1" src="https://github.com/user-attachments/assets/01e0ee49-7db3-487b-8eeb-54c2d1971560" />

Связь между ними: один пользователь имеет много сообщений, одно сообщение принадлежит одному пользователю.

В файле crud.py написаны функции для работы с БД:
- get_or_create_user() — ищет пользователя по Telegram ID, если не найден — создаёт
- add_message() — добавляет сообщение в таблицу
- get_last_messages() — извлекает последние N сообщений для контекста
- reset_context() — удаляет все сообщения пользователя

### Этап 5. Интеграция с Groq API

Вместо использования OpenAI API (платно), выбрали Groq. API совместим — принимает такой же формат сообщений.
<img width="1048" height="778" alt="3" src="https://github.com/user-attachments/assets/0aaa47b1-f9ab-48d0-8f0b-830b99a5119e" />

Функция get_response() делает следующее:
1. Собирает систему из двух частей:
   - SYSTEM_PROMPT из .env (общее поведение бота)
   - Дополнительное указание обращаться по имени пользователя
2. Добавляет исторический контекст (последние сообщения из БД)
3. Отправляет всё в Groq API (модель llama-3.1-8b-instant)
4. Возвращает ответ ассистента


### Этап 6. Обработчики команд

В Aiogram обработчики регистрируются через декоратор @dp.message(...).

**Команда /start:**
- Получает Telegram ID и имя пользователя из объекта Message
- Создаёт или получает существующего пользователя в БД
- Отправляет приветственное сообщение с информацией о доступных командах

**Команда /reset-context:**
- Создаёт или получает пользователя
- Удаляет все его сообщения из БД через функцию reset_context()
- Подтверждает сброс контекста

### Этап 7. Обработчик сообщений

Основная логика работает в message_handler():

1. Проверяет что пришло текстовое сообщение (не команда, не медиа)
2. Создаёт или получает пользователя в БД
3. Сохраняет сообщение пользователя в БД с role="user"
4. Загружает последние 12 сообщений из БД (контекст)
5. Отправляет контекст в Groq API вместе с именем пользователя
6. Получает ответ ассистента
7. Сохраняет ответ в БД с role="assistant"
8. Отправляет ответ пользователю в Telegram

Благодаря асинхронности вся цепочка работает быстро, даже если много пользователей.

**Обработчик фотографий:**
- Отдельный обработчик проверяет наличие photo в сообщении
- Сохраняет в БД что пользователь отправил фото (как "[PHOTO]")
- Отвечает текстом "Вы отправили картинку!"
- Не обрабатывает фото нейросетью (как и требовало задание)

### Этап 8. Главный файл (main.py)

Точка входа делает три вещи:
1. init_db() — создаёт все таблицы в БД при первом запуске
2. dp.start_polling(bot) — запускает бесконечный цикл, который слушает входящие сообщения от Telegram
3. Логирование настраивается на уровне INFO в консоль

## Установка и настройка

```bash
python main.py
```

После успешного запуска бот начнет слушать входящие сообщения.

## Команды бота

| Команда | Описание |
|---------|----------|
| /start | Начало диалога, приветствие и информация о командах |
| /reset-context | Сброс контекста диалога (удаление истории сообщений) |

## Как это работает

Основной рабочий процесс бота:

1. Пользователь отправляет /start
2. Бот создает запись пользователя в БД
3. Пользователь отправляет сообщение
4. Сообщение сохраняется в БД с ролью "user"
5. Бот загружает последние сообщения из контекста (до 12)
6. Отправляет их вместе с системным промптом в Groq API
7. Получает ответ ассистента и сохраняет его в БД
8. Отправляет ответ пользователю в Telegram

## Скрины работы бота
